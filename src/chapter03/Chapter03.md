# Chapter 03: 모든 객체의 공통 메서드

## Item 10: equals는 일반 규약을 지켜 재정의하라

### equals 메서드를 재정의하지 않는 것이 좋은 상황
1. 각 인스턴스가 본질적으로 고유하다 (예: `Thread`).  
   - 값을 표현하는 것이 아니라 동작하는 객체.
2. 인스턴스의 **논리적 동치성**을 검사할 일이 없다.
3. 상위 클래스에서 정의한 `equals`가 하위 클래스에도 딱 들어맞는다.

### equals 메서드가 지켜야 할 규약
(x, y, z는 `null`이 아닌 값):
1. **반사성**:  
   - `x.equals(x)`는 항상 `true`를 반환해야 한다.
2. **대칭성**:  
   - `x.equals(y)`가 `true`이면 `y.equals(x)`도 `true`여야 한다.
3. **추이성**:  
   - `x.equals(y)`가 `true`이고, `y.equals(z)`가 `true`이면 `x.equals(z)`도 `true`여야 한다.
4. **일관성**:  
   - `x.equals(y)`를 반복 호출해도 항상 같은 값을 반환해야 한다.
5. **null-아님**:  
   - `x.equals(null)`은 항상 `false`를 반환해야 한다.

### 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.

### equals 메서드를 구현하는 방법
1. `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. `instanceof` 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 올바른 타입으로 형변환한다.
4. 입력 객체와 자신의 대응되는 **핵심 필드**들이 모두 일치하는지 확인한다.

### 기본 타입과 참조 타입 비교 방법
- 기본 타입: `==` 사용.
- 참조 타입: `equals` 사용.
- `float`와 `double`: `compareTo` 사용.  
  - 이유: `NaN`, `-0.0f`, 부동 소수점을 다뤄야 하기 때문.

### equals 재정의 시 주의사항
1. `equals`를 재정의할 때는 `hashCode`도 반드시 재정의하라.
2. 너무 복잡하게 해결하려 들지 말자.
3. `Object` 외의 타입을 매개변수로 받는 `equals` 메서드는 선언하지 말자.

---

## Item 11: equals를 재정의하려거든 hashCode도 재정의하라
- `equals(Object)`가 두 객체를 같다고 판단했다면, 두 객체의 `hashCode`는 똑같은 값을 가져야 한다.

---

## Item 12: toString()을 항상 재정의하라
- 모든 구체 클래스에서 `Object`의 `toString()`을 재정의하라.
- `toString()`을 통해 디버깅 및 객체 내용을 쉽게 확인할 수 있다.

---

## Item 13: clone 재정의는 주의해서 진행하라
- `clone` 메서드는 사실상 생성자와 같은 효과를 낸다.
- `clone`은 원본 객체에 해를 끼치지 않으면서 복제된 객체의 불변식을 보장해야 한다.

---

## Item 14: Comparable을 구현할지 고려하라
- `Comparable`을 구현하면 객체 간의 자연 순서를 정의할 수 있다.
- 구현 시 객체의 정렬 및 검색 작업에 유리하다.
